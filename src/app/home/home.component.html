<div class="margin-top-10px">
  Use the navigation button to go to the desired example.
  <div class="categories-row">
    <div class="categories-column">

      <div class="category">
        <b><u>01-Creation:</u></b>
        <ul>

          <li>
            <span class="operator-title">.of()</span>
            <b>Description:</b> Emit variable amount of values in a sequence.<br>
            <b>signature:</b> of(...values, scheduler: Scheduler): Observable
          </li>

          <li>
            <span class="operator-title"> .from() (does also what .fromPromise() does)</span>
            <b>Description:</b> Turn an array, promise, or iterable into an observable.<br>
            <b>signature:</b> from(ish: ObservableInput, mapFn: function, thisArg: any, scheduler: Scheduler):
            Observable
          </li>

          <li>
            <span class="operator-title"> .create()</span>
            <b>Description:</b> Create an observable with given subscription function.<br>
            <b>signature:</b> create(subscribe: function)
          </li>

          <li>
            <span class="operator-title"> .fromEvent()</span>
            <b>Description:</b> Turn event into observable sequence.<br>
            <b>Signature:</b> fromEvent(target: EventTargetLike, eventName: string, selector: function):
            Observable
          </li>

          <li>
            <span class="operator-title"> .interval(x ms)</span>
            <b>Description:</b> Emit numbers in sequence based on provided timeframe.<br>
            <b>Signature:</b> interval(period: number, scheduler: Scheduler): Observable
          </li>

          <li>
            <span class="operator-title"> .range(x,y)</span>
            <b>Description:</b> Emit numbers in provided range in sequence.<br>
            <b>Signature:</b> range(start: number, count: number, scheduler: Scheduler): Observable
          </li>

          <li>
            <span class="operator-title"> .timer()</span>
            <b>Description:</b> After given duration, emit numbers in sequence every specified duration.<br>
            <b>Signature:</b> timer(initialDelay: number | Date, period: number, scheduler: Scheduler):
            Observable
          </li>

          <li>
            <span class="operator-title"> .throw(new Error('Error'))</span>
            <b>Description:</b> Emit error on subscription.<br>
            <b>Signature:</b> throw(error: any, scheduler: Scheduler): Observable
          </li>

        </ul>
      </div>

      <div class="category">
        <b><u>02-Combining:</u></b>
        <ul>

          <li>
            <span class="operator-title"> .combineLatest()</span>
            <b>Description:</b> When any observable emits a value, emit the latest value from each.<br>
            <b>signature:</b> combineLatest(observables: ...Observable, project: function): Observable
          </li>

          <li>
            <span class="operator-title"> .zip()</span>
            <b>Description:</b> After all observables emit, emit all values with the same index as an
            array<br>
            <b>signature:</b> zip(observables: *): Observable
          </li>

          <li>
            <span class="operator-title"> .forkJoin()</span>
            <b>Description:</b> When all observables complete, emit the last emitted value from each.<br>
            <b>signature:</b> forkJoin(...args, selector : function): Observable
          </li>

          <li>
            <span class="operator-title"> .race(Obs1, Obs2)</span>
            <b>Description:</b> Returns the observable to emit first.<br>
            <b>signature:</b> race(observables: ...Observable): Observable
          </li>

        </ul>
      </div>

      <div class="category">
        <b><u>03-Merging - linear:</u></b>
        <ul>

          <li>
            <span class="operator-title"> .map()</span>
            <b>Description:</b> Apply projection with each value from source.<br>
            <b>signature:</b> map(project: Function, thisArg: any): Observable
          </li>

          <li>
            <span class="operator-title"> .merge()</span>
            <b>Description:</b> Turn multiple observables into a single observable.<br>
            <b>signature:</b> merge(input: Observable): Observable
          </li>

          <li>
            <span class="operator-title"> .concat()</span>
            <b>Description:</b> Subscribe to observables in order as previous completes, emit values.<br>
            <b>signature:</b> concat(observables: ...*): Observable
          </li>

        </ul>
      </div>
    </div>

    <div class="categories-column">

      <div class="category">
        <b><u>04-Merging - flattening:</u></b>
        <br>
        double operation operators with flattening
        <ul>
          <li>
            <span class="operator-title"> .mergeMap()</span>
            <b>Description:</b> Returns the observable to emit first.<br>
            <b>signature:</b> mergeMap(project: function: Observable, resultSelector: function: any,
            concurrent:
            number): Observable
          </li>

          <li>
            <span class="operator-title"> .concatMap()</span>
            <b>Description:</b> Map values to inner observable, subscribe and emit in order.<br>
            <b>signature:</b> concatMap(project: function, resultSelector: function): Observable
          </li>

          <li>
            <span class="operator-title"> .switchMap()</span>
            <b>Description:</b> Map to observable, complete previous inner observable, emit values.<br>
            <b>signature:</b> switchMap(project: function: Observable, resultSelector: function(outerValue,
            innerValue, outerIndex, innerIndex): any): Observable
          </li>

        </ul>
      </div>

      <div class="category">
        <b><u>05-Share/Replay:</u></b>
        <!--        <ul>
                  <li>
                    <span class="operator-title"> .share()</span>
                    <b>Description:</b> Share source among multiple subscribers.<br>
                    <b>signature:</b> share(): Observable
                  </li>

                  <li>
                    <span class="operator-title"> .shareReplay()</span>
                    <b>Description:</b> Share source among multiple subscribers with a ReplaySubject.<br>
                    <b>signature:</b> shareReplay(count: number): Observable
                  </li>

                  <li>
                    <span class="operator-title"> .publish()</span>
                    <b>Description:</b> Share source and make hot (individually) by calling .connect().<br>
                    <b>signature:</b> publish() : ConnectableObservable
                  </li>

                  <li>
                    <span class="operator-title"> .publishReplay()</span>
                    <b>Description:</b> Share source among multiple subscribers.<br>
                    <b>signature:</b> share(): Observable
                  </li>

                  <li>
                    <span class="operator-title"> .refCount()</span>
                    <b>Description:</b> .<br>
                    <b>signature:</b> refCount(): Observable
                  </li>

                </ul>-->
        <ul>

          <li>
            <span class="operator-title"> .shareReplay(n)</span>
            <b>Description:</b> Share source among multiple subscribers with a ReplaySubject.<br>
            Automatically starts emitting on 1st subscriber.<br>
            Does not reset when all subscribers have unsubscribed.<br>
            Continues emitting as long as the stream is not destroyed (e.g. lives in an angular service)<br>
            <b>signature:</b> shareReplay(count: number): Observable
          </li>

          <li>
            <span class="operator-title"> .publishReplay(n).refCount()</span>
            <b>.publishReplay():</b> Share source among multiple subscribers.<br>
            <b>.refCount():</b> (not official) Automatically handles subscriptions, <br>
            eliminating the need for using connect().<br>
            Automatically starts emitting on 1st subscriber.<br>
            Resets (disconnects from source) when all subscribers unsubscribed.<br>

            <b>signature:</b> publishReplay(): Observable
            <b>signature:</b> refCount(): Observable
          </li>

        </ul>
      </div>

      <div class="category">
        <b><u>06-Filtering:</u></b>
        <ul>

          <li>
            <span class="operator-title"> .filter(func)</span>
            <b>Description:</b> Emit values that pass the provided condition.<br>
            <b>Signature:</b> filter(select: Function, thisArg: any): Observable
          </li>

          <li>
            <span class="operator-title"> .first()</span>
            <b>Description:</b> Emit the first value or first to pass provided expression.<br>
            <b>Signature:</b> first(predicate: function, select: function)
          </li>

          <li>
            <span class="operator-title"> .take(n)</span>
            <b>Description:</b> Emit provided number of values before completing.<br>
            <b>Signature:</b> take(count: number): Observable
          </li>

          <li>
            <span class="operator-title"> .takeLast(n)</span>
            <b>Description:</b> Emit the last values emitted from source on completion, based on provided
            number.<br>
            <b>Signature:</b> takeLast(count: number): Observable
          </li>

          <li>
            <span class="operator-title"> .last(n)</span>
            <b>Description:</b> Emit the last value emitted from source on completion, based on provided
            expression.
            <b>Signature:</b> last(predicate: function): Observable
          </li>

          <li>
            <span class="operator-title"> .takeUntil(Observable)</span>
            <b>Description:</b> Emit values until provided observable emits.<br>
            <b>Signature:</b> takeUntil(notifier: Observable): Observable
          </li>

          <li>
            <span class="operator-title"> .takeWhile(function)</span>
            <b>Description:</b> Emit values until provided expression is false.<br>
            <b>Signature:</b> takeWhile(predicate: function(value, index): boolean): Observable
          </li>

        </ul>
      </div>
    </div>

    <div class="categories-column">

      <div class="category">
        <b><u>07-Other:</u></b>
        <ul>
          <li>
            <span class="operator-title"> .scan()</span>
            <b>Description:</b> Reduce over time..<br>
            <b>Signature:</b> scan(accumulator: function, seed: any): Observable
          </li>

          <li>
            <span class="operator-title"> .do()</span>
            <b>Description:</b> Transparently perform actions or side-effects, such as logging.<br>
            <b>Signature:</b> do(nextOrObserver: function, error: function, complete: function): Observable
          </li>

          <li>
            <span class="operator-title"> .defaultIfEmpty()</span>
            <b>Description:</b> Emit given value if nothing is emitted before completion.<br>
            <b>Signature:</b> defaultIfEmpty(defaultValue: any): Observable
          </li>

          <li>
            <span class="operator-title"> .debounce()</span>
            <b>Description:</b> Discard emitted values that take less than the specified time, based on
            selector
            function, between output.<br>
            <b>Signature:</b> debounce(durationSelector: function): Observable
          </li>

          <li>
            <span class="operator-title"> .debounceTime()</span>
            <b>Description:</b> Discard emitted values that take less than the specified time between
            output.<br>
            <b>Signature:</b> debounceTime(dueTime: number, scheduler: Scheduler): Observable
          </li>

          <li>
            <span class="operator-title"> .throttle()</span>
            <b>Description:</b> Emit value only when duration, determined by provided function, has
            passed.<br>
            <b>Signature:</b> throttle(durationSelector: function(value): Observable | Promise): Observable
          </li>

          <li>
            <span class="operator-title"> .throttleTime()</span>
            <b>Description:</b> Emit latest value when specified duration has passed.<br>
            <b>Signature:</b> throttleTime(duration: number, scheduler: Scheduler): Observable
          </li>

          <li>
            <span class="operator-title"> .distinctUntilChanged()</span>
            <b>Description:</b> Emit values until provided observable emits.<br>
            <b>Signature:</b> takeUntil(notifier: Observable): Observable
          </li>

          <li>
            <span class="operator-title"> .startWith()</span>
            <b>Description:</b> Emit given value first.<br>
            <b>Signature:</b> startWith(an: Values): Observable
          </li>

          <li>
            <span class="operator-title"> .retry(n)</span>
            <b>Description:</b> Emit values until provided observable emits.<br>
            <b>Signature:</b> takeUntil(notifier: Observable): Observable
          </li>

          <li>
            <span class="operator-title"> .retryWhen()</span>
            <b>Description:</b> Emit values until provided observable emits.<br>
            <b>Signature:</b> takeUntil(notifier: Observable): Observable
          </li>

        </ul>
      </div>
    </div>
  </div>
</div>
